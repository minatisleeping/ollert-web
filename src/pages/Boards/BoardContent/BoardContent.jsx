import Box from '@mui/material/Box'
import ListColumns from './ListColumns/ListColumns'
import { mapOrder } from '~/utils/sort'

import {
  DndContext,
  // PointerSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  DragOverlay,
  defaultDropAnimationSideEffects,
  closestCorners
} from '@dnd-kit/core'
import { arrayMove } from '@dnd-kit/sortable'
import { useEffect, useState } from 'react'
import { cloneDeep } from 'lodash'

import Column from './ListColumns/Column/Column'
import Card from './ListColumns/Column/ListCards/Card/Card'

const ACTIVE_DRAG_ITEM_TYPE = {
  COLUMN: 'ACTIVE_DRAG_ITEM_TYPE_COLUMN',
  CARD: 'ACTIVE_DRAG_ITEM_TYPE_CARD'
}

function BoardContent({ board }) {
  // pointer sensor c≈©ng ngon nh∆∞ng c√≤n v√†i case ch∆∞a th·∫≠t s·ª± ·ªïn n√™n m√¨nh chuy·ªÉn qua d√πng mouse sensor
  //const pointerSensor = useSensor(PointerSensor, { activationConstraint: { distance: 10 } }) // >= 10px th√¨ m·ªõi t√≠nh l√† k√©o

  // Y√™u c·∫ßu chu·ªôt di chuy·ªÉn 10px th√¨ m·ªõi k√≠ch ho·∫°t event, fix tr∆∞·ªùng h·ª£p click th√¨ g·ªçi event
  const mouseSensor = useSensor(MouseSensor, { activationConstraint: { distance: 10 } })

  // Nh·∫•n gi·ªØ 250ms va2 dung sai c·ªßa c·∫£m ·ª©ng 500px th√¨ m·ªõi k√≠ch ho·∫°t event
  const touchSensor = useSensor(TouchSensor, { activationConstraint: { delay: 250, tolerance: 500 } })

  // ∆Øu ti√™n s·ª≠ d·ª•ng k·∫øt h·ª£p c·∫£ 2 sensor ƒë·ªÉ tƒÉng tr·∫£i nghi·ªám cho ng∆∞·ªùi d√πng(speialy in mobile device)
  // const sensors = useSensors(pointerSensor) // k d√πng pointer sensor n·ªØa
  const sensors = useSensors(mouseSensor, touchSensor)

  const [orderedColumns, setOrderedColumns] = useState([])

  // C√πng m·ªôt th√¨ ƒëi·ªÉm ch·ªâ c√≥ 1 ph·∫ßn t·ª≠ ƒë∆∞·ª£c k√©o (column ho·∫∑c card)
  const [activeDragItemId, setActiveDragItemId] = useState(null)
  const [activeDragItemType, setActiveDragItemType] = useState(null)
  const [activeDragItemData, setActiveDragItemData] = useState(null)
  const [oldColumnWhenDraggingCard, setOldColumnWhenDraggingCard] = useState(null)

  useEffect(() => {
    setOrderedColumns(mapOrder(board?.columns, board?.columnOrderIds, '_id'))
  }, [board])

  // T√¨m m·ªôt c√°i Column theo CardId
  const findColumnByCardId = (cardId) => {
    /* N√™n d√πng column.cardId thay v√¨ column.cardOrderIds v√¨ ·ªü b∆∞·ªõc handleDragOver m√¨nh s·∫Ω l√†m d·ªØ li·ªáu cho cards
    ho√†n ch·ªânh tr∆∞·ªõc r·ªìi m·ªõi t·∫°o ra cardOrderIds m·ªõi */
    return orderedColumns.find(column => column?.cards?.map(card => card._id)?.includes(cardId))
  }

  // ! Trigger khi b·∫Øt ƒë·∫ßu k√©o 1 ph·∫ßn t·ª≠
  const handleDragStart = (event) => {
    // console.log('üöÄ ~ handleDragStart: ', event)
    setActiveDragItemId(event?.active?.id)
    setActiveDragItemType(event?.active?.data?.current?.columnId ? ACTIVE_DRAG_ITEM_TYPE.CARD : ACTIVE_DRAG_ITEM_TYPE.COLUMN)
    setActiveDragItemData(event?.active?.data?.current)

    // N·∫øu lal2 k√©o Card th√¨ m·ªõi th·ª±c hi·ªán hannh2 ƒë·ªôn set gi√° tr·ªã oldColumn
    if (event?.active?.data?.current?.columnId) {
      setOldColumnWhenDraggingCard(findColumnByCardId(event?.active?.id))
    }
  }

  // ! Trigger trong qu√° tr√¨nh k√©o 1 ph·∫ßn t·ª≠
  const handleDragOver = (event) => {
    // Kh√¥ng l√†m g√¨ th√™m n·∫øu ƒëang k√©o Column
    if (activeDragItemType === ACTIVE_DRAG_ITEM_TYPE.COLUMN) return

    // C√≤n n·∫øu k√©o Card th√¨ x·ª≠ l√≠ th√™m ƒë·ªÉ c√≥ th·ªÉ k√©o Card qua l·∫°i gi·ªØa c√°c Columns
    // console.log('üöÄ handleDragOver: ', event)
    const { active, over } = event

    // C·∫ßn ƒë·∫£m b·∫£o n·∫øu k t·ªìn t·∫°i active or over (khi k√©o ra kh·ªèi ph·∫°m vi container) th√¨ k l√†m g√¨ (tr√°nh crash trang)
    if (!active || !over) return

    // activeDraggingCard: l√† c√°i Card ƒëang ƒë∆∞·ª£c k√©o
    const { id: activeDraggingCardId, data: { current: activeDraggingCardData } } = active
    // overCard: l√† c√°c Card ƒëang t∆∞∆°ng t√°c ·ªü ph√≠a tr√™n ho·∫∑c d∆∞·ªõi so v·ªõi c√°i Card ƒë∆∞·ª£c k√©o ·ªü tr√™n
    const { id: overCardId } = over

    // * T√¨m 2 c√°i column theo cardId
    const activeColumn = findColumnByCardId(activeDraggingCardId)
    const overColumn = findColumnByCardId(overCardId)

    if (!activeColumn || !overColumn) return

    // ! T·ªõi ƒë∆∞·ª£c ƒë√¢y th√¨ c√≥ nghƒ©a l√† activeColumn v√† overColumn ƒë√£ ƒë∆∞·ª£c t√¨m th·∫•y
    // * X·ª≠ l√≠ logic ·ªü ƒë√¢y ch·ªâ khi k√©o card qua 2 columns kh√°c nhau, c√≤n n·∫øu k√©o card trong ch√≠nh column ban ƒë·∫ßu
    //c·ªßa n√≥ th√¨ kh√¥ng l√†m g√¨ c·∫£
    // * V√¨ ƒë√¢y l√† ƒëo·∫°n x·ª≠ l√≠ l√∫c k√©o (handleDragOver), c√≤n x·ª≠ l√≠ l√∫c k√©o xong xu√¥i th√¨ n√≥ l·∫°i l√† v·∫•n ƒë·ªÅ kh√°c ·ªü
    //(handleDragEnd)
    if (activeColumn._id !== overColumn._id) {
      setOrderedColumns(prevColumn => {
        // T√¨m v·ªã tr√≠ (index) c·ªßa c√°i overCard trong Column ƒë√≠ch (n∆°i m√† activeCard s·∫Øp ƒë∆∞·ª£c th·∫£)
        const overCardIndex = overColumn?.cards?.findIndex(card => card._id === overCardId)

        // Logic t√≠nh to√°n 'cardIndex m·ªõi' (tr√™n ho·∫∑c d∆∞·ªõi c·ªßa overCard) l·∫•y chu·∫©n ra t·ª´ code c·ªßa th∆∞ vi·ªán
        let newCardIndex
        const isBelowOverItem = active.rect.current.translated &&
          active.rect.current.translated.top > over.rect.top + over.rect.height
        const modifier = isBelowOverItem ? 1 : 0
        newCardIndex = overCardIndex >= 0 ? overCardIndex + modifier : overColumn?.cards?.length + 1

        // * Clone m·∫£ng OrderedColumnsState c≈© ra m·ªôt c√°i m·ªõi ƒë·ªÉ x·ª≠ l√Ω data r·ªìi return - c·∫≠p nh·∫≠t l·∫°i OrderedColumnsState m·ªõi
        const nextColumns = cloneDeep(prevColumn)
        const nextActiveColumn = nextColumns.find(column => column._id === activeColumn._id)
        const nextOverColumn = nextColumns.find(column => column._id === overColumn._id)

        // nextActiveColumn: Column c≈©
        if (nextActiveColumn) {
          // Xo√° card ·ªü c√°i column active (c≈©ng c√≥ th·ªÉ hi·ªÉu l√† column c≈©, c√°i l√∫c m√† k√©o card ra kh·ªèi n√≥ ƒë·ªÉ sang column kh√°c)
          nextActiveColumn.cards = nextActiveColumn.cards.filter(card => card._id !== activeDraggingCardId)
          // C·∫≠p nh·∫≠t l·∫°i m·∫£ng cardOrderIds cho chu·∫©n d·ªØ li·ªáu
          nextActiveColumn.cardOrderIds = nextActiveColumn.cards.map(card => card._id)
        }

        // nextOverColumn: Column m·ªõi
        if (nextOverColumn) {
          // Ki·ªÉm tra xem Card ƒëang k√©o n√≥ c√≥ t·ªìn t·∫°i ·ªü overColumn ch∆∞a, n·∫øu co th√¨ xo√° n√≥ ƒëi tr∆∞·ªõc khi th√™m v√†o
          nextOverColumn.cards = nextOverColumn.cards.filter(card => card._id !== activeDraggingCardId)
          // Ti·∫øp theo l√† th√™m c√°i Card ƒëang k√©o v√†o overColumn theo v·ªã tr√≠ index m·ªõi
          nextOverColumn.cards = nextOverColumn.cards.toSpliced(newCardIndex, 0, activeDraggingCardData)
          // C·∫≠p nh·∫≠t l·∫°i m·∫£ng cardOrderIds cho chu·∫©n d·ªØ li·ªáu
          nextOverColumn.cardOrderIds = nextOverColumn.cards.map(card => card._id)
        }

        // console.log('üöÄ ~ handleDragOver ~ nextColumns:', nextColumns)
        return nextColumns
      })
    }
  }

  // ! Trigger khi k·∫øt th√∫c h√†nh ƒë·ªông k√©o 1 ph·∫ßn t·ª≠
  const handleDragEnd = (event) => {
    // console.log('üöÄ ~ handleDragEnd: ', event)
    const { active, over } = event // active: l√† th·∫±ng ƒëang k√©o, over: l√† th·∫±ng b·ªã k√©o

    // C·∫ßn ƒë·∫£m b·∫£o n·∫øu k t·ªìn t·∫°i active or over (khi k√©o ra kh·ªèi ph·∫°m vi container) th√¨ k l√†m g√¨ (tr√°nh crash trang)
    if (!active || !over) return

    if (activeDragItemType === ACTIVE_DRAG_ITEM_TYPE.CARD) {

      // activeDraggingCard: l√† c√°i Card ƒëang ƒë∆∞·ª£c k√©o
      const { id: activeDraggingCardId, data: { current: activeDraggingCardData } } = active
      // overCard: l√† c√°c Card ƒëang t∆∞∆°ng t√°c ·ªü ph√≠a tr√™n ho·∫∑c d∆∞·ªõi so v·ªõi c√°i Card ƒë∆∞·ª£c k√©o ·ªü tr√™n
      const { id: overCardId } = over

      // * T√¨m 2 c√°i column theo cardId
      const activeColumn = findColumnByCardId(activeDraggingCardId)
      const overColumn = findColumnByCardId(overCardId)

      if (!activeColumn || !overColumn) return

      /* H√†nh ƒë·ªông k√©o th·∫£ card gi·ªØa 2 column kh√°c nhau
         Ph·∫£i d√πng t·ªõi activeDragItemData.columnId or oldColumnWhenDraggingCard._id (set v√†o state
      t·ª´ b∆∞·ªõc handleDragStart) ch·ª© k ph·∫£i activeData trong scope handleDragEnd n√†y v√¨ sau khi
      ƒëi qua onDragOver t·ªõi ƒë√¢y l√† state c·ªßa card ƒë√£ b·ªã update 1 l·∫ßn r·ªìi */
      if (oldColumnWhenDraggingCard._id !== overColumn._id) {
        //
      } else {
        // H√†nh ƒë·ªông k√©o th·∫£ card trong c√πng 1 column

        // L·∫•y v·ªã tr√≠ c≈© (t·ª´ th·∫±ng oldColumnWhenDraggingCard)
        const oldCardIndex = oldColumnWhenDraggingCard?.cards?.findIndex(c => c._id === activeDragItemId) // set oldIndex === active.id t·ª©c l√† l·∫•y index c·ªßa th·∫±ng ƒëang b·ªã k√©o
        // L·∫•y v·ªã tr√≠ m·ªõi t·ª´ th·∫±ng over
        const newCardIndex = overColumn?.cards?.findIndex(c => c._id === overCardId) // set oldIndex === active.id t·ª©c l√† l·∫•y index c·ªßa th·∫±ng ƒëang b·ªã k√©o

        const dndOrderedCards = arrayMove(oldColumnWhenDraggingCard?.cards, oldCardIndex, newCardIndex)

        setOrderedColumns(prevColumn => {
          // * Clone m·∫£ng OrderedColumnsState c≈© ra m·ªôt c√°i m·ªõi ƒë·ªÉ x·ª≠ l√Ω data r·ªìi return - c·∫≠p nh·∫≠t l·∫°i OrderedColumnsState m·ªõi
          const nextColumns = cloneDeep(prevColumn)

          // T√¨m t·ªõi c√°i Column m√† ta ƒëang th·∫£
          const targetColumn = nextColumns.find(column => column._id === overColumn._id)

          // C·∫≠p nh·∫≠t l·∫°i 2 gi√° tr·ªã m·ªõi l√† Card v√† cardOrderIDs trong c√°i targetColumn
          targetColumn.cards = dndOrderedCards
          targetColumn.cardOrderIds = dndOrderedCards.map(card => card._id)

          // Tr·∫£ v·ªÅ gi√° tr·ªã state m·ªõi (chu·∫©n v·ªã tri1)
          return nextColumns
        })
      }
    }

    // ! X·ª≠ l√≠ k√©o th·∫£ Columns
    if (activeDragItemType === ACTIVE_DRAG_ITEM_TYPE.COLUMN) {
      console.log('H√†nh ƒë·ªông k√©o th·∫£ Column')
      // N·∫øu newIndex != oldIndex th√¨ m·ªõi th·ª±c hi·ªán s·∫Øp x·∫øp l·∫°i m·∫£ng
      if (active.id !== over.id) { // T·∫°i sao active v√† over l·∫°i l√† .id ? V√¨ m√¨nh ƒëang s·ª≠ d·ª•ng th∆∞ vi·ªán c·ªßa n√≥(n√≥ s·ª≠ d·ª•ng key l√† id) =))
        // L·∫•y v·ªã tr√≠ c≈© t·ª´ th·∫±ng active
        const oldColumnIndex = orderedColumns.findIndex(c => c._id === active.id) // set oldIndex === active.id t·ª©c l√† l·∫•y index c·ªßa th·∫±ng ƒëang b·ªã k√©o
        // L·∫•y v·ªã tr√≠ m·ªõi t·ª´ th·∫±ng over
        const newColumnIndex = orderedColumns.findIndex(c => c._id === over.id) // set oldIndex === active.id t·ª©c l√† l·∫•y index c·ªßa th·∫±ng ƒëang b·ªã k√©o

        // D√πng arrayMove c·ªßa th·∫±ng dnd-kit ƒë·ªÉ s·∫Øp x·∫øp l·∫°i m·∫£ng Columns ban ƒë·∫ßu
        const dndOrderedColumns = arrayMove(orderedColumns, oldColumnIndex, newColumnIndex) // k√©o t·ª´ th·∫±ng n√†o ƒë·∫øn th·∫±ng n√†o n√™n m·ªõi old tr∆∞·ªõc new sau
        // 2 c√°i console.log d·ªØ li·ªáu n√†y sau d√πng ƒë·ªÉ x·ª≠ l√Ω g·ªçi API
        // const dndOrderedColumnsIds = dndOrderedColumns.map(c => c._id) // Sau khi drag&drop column xong th√¨ set l·∫°i gi√° tr·ªã cho columnOrderIds(value c·ªßa columnOrderIds s·∫Ω quy·∫øt ƒë·ªãnh v·ªã tr√≠ c·ªßa t·ª´ng column)
        // console.log('üöÄ ~ dndOrderedColumns ~ dndOrderedColumns:', dndOrderedColumns)
        // console.log('üöÄ ~ dndOrderedColumnsIds ~ dndOrderedColumnsIds:', dndOrderedColumnsIds)

        // C·∫≠p nh·∫≠t l·∫°i state columns ban ƒë·∫ßu sau khi ƒë√£ k√©o th·∫£
        setOrderedColumns(dndOrderedColumns)
      }
    }

    // Nh·ªØng d·ªØ li·ªáu sau khi k√©o th·∫£ n√†y lun ph·∫£i ƒë∆∞a v·ªÅ gi√° tr·ªã null m·∫∑c ƒë·ªãnh ban ƒë·∫ßu
    setActiveDragItemId(null)
    setActiveDragItemType(null)
    setActiveDragItemData(null)
    setOldColumnWhenDraggingCard(null)
  }

  // Animation khi th·∫£ (drop) ph·∫ßn t·ª≠ - Test b·∫±ng c√°ch k√©o xong th·∫£ tr·ª±c ti·∫øp v√† nh√¨n ph·∫ßn gi·ªØ ch·ªó Overlay
  const customDropAnimation = {
    sideEffects: defaultDropAnimationSideEffects({ styles: { active: { opacity: '0.5' } } })
  }

  return (
    <DndContext
      sensors={sensors}
      /* Thu·∫≠t to√°n ph√°t hi·ªán va ch·∫°m (n·∫øu kh√¥ng c√≥ n√≥ th√¨ Card v·ªõi cover l·ªõn s·∫Ω kh√¥ng k√©o qua Column ƒë∆∞·ª£c
      v√¨ l√∫c n√†y n√≥ ƒëang b·ªã conflict gi·ªØa Card v√† Column), ch√∫ng ta s·∫Ω d√πng closestCorners thay v√¨ closestCenter */
      collisionDetection={closestCorners}
      onDragStart={handleDragStart}
      onDragOver={handleDragOver}
      onDragEnd={handleDragEnd}
    >
      <Box sx={{ //Board Bar
        bgcolor: theme => theme.palette.mode === 'dark' ? '#34495e' : '#1976d2',
        width: '100%',
        height: theme => theme.trello.boardContentHeight,
        p: '10px 0'
      }}>
        <ListColumns columns={orderedColumns} />
        <DragOverlay dropAnimation={customDropAnimation}>
          {(!activeDragItemType) && null}
          {(activeDragItemType === ACTIVE_DRAG_ITEM_TYPE.COLUMN) && <Column column={activeDragItemData} />}
          {(activeDragItemType === ACTIVE_DRAG_ITEM_TYPE.CARD) && <Card card={activeDragItemData} />}
        </DragOverlay>
      </Box>
    </DndContext>
  )
}

export default BoardContent
